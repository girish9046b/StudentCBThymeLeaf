ANNAPURNA

SPRING BOOT,
TL

SpringSecurityConfig
StudentController
RestStudentController	
RestTemplateStudent
EmailService
refre form 36- AOP


springs boot tutorial :
https://howtodoinjava.com/interview-questions/spring-boot-interview-questions/#14

Always RunAs--> MavenInstall when starting a nuw project build
If STS does not jave a pivotal servers setup an external server



1) Springs Annotations :

			--> @Controller , @Service , @Repository are different specializations of @Component annotation.
			--> @Controller  -- The dispatcher scans @Controller annotated classes for mapped methods and detects @RequestMapping annotations.
			--> @Service annotation is used in your service layer and annotates classes that perform service tasks
			--> @Repository is an annotation that marks the specific class as a Data Access Object
			--> @ComponentScan If you specify the above annotations(@Controller , @Component , @Service , @Repository) then the class is eligible for the ComponentScan, then can be autowired/injected.
			--> @Configuration annotation indicates that a class declares one or more @Bean methods and may be processed by the Spring container 
			
			--> @Autowired: to inject dependency at run-time by spring, means in a class, autowire a object.
			--> @Bean works in conjunction with a configuration class,Telling Spring to add whatever the method returns to the Spring Context.
			--> @ConfigurationProperties(prefix = "hdatasource.marks") -  used to read the db configuration for application.properties
			--> @Primary -- For multiple beans @Autowired without any @Qualifier , the bean marked @Primary will be chosen
			--> @Qualifier --  For multiple beans @Autowired , then use  @Qualifier  and choose which one it wants
			--> @Value annotation to inject values from a property file into a bean’s attribute.
			--> @Lazy - By default all autowired dependencies are created and configured at startup. But if you want to initialize a bean lazily
			
			--> @CrossOrigin - In many cases the host that serves JavaScript will be different from the host that serves the data. In such a case Cross Origin Resource Sharing (CORS) enables cross-domain communication.
			--> @RequestMapping - The @RequestMapping annotation is used to map web requests onto specific handler classes and handler methods
			--> @PathVariable - URI where certain URI value acts as a parameter - http://example.com/1
			--> @RequestParam - annotation is used bind the parameter values from query string - http://example.com?ID=1
			--> @RequestBody - annotation indicates that a method parameter should be bound to the value of the HTTP request body
			--> @RequestPart - This annotation takes into consideration the “Content-Type” header in the multipart(request part).
			--> @ResponseBody - annotation indicates that the result type should be written straight in the response body in whatever format you specify like JSON or XML
			--> @Valid -  To make a model eligible for form validation -public ModelAndView LoginCheck(@Valid Login login
			--> @ControllerAdvice - This annotation is used to define @ExceptionHandler
			--> @ExceptionHandler - This annotation is used at method levels to handle exception at the controller level
			--> @ResponseStatus marks a method or exception class with a status code and a reason that must be returned
			
			
			--> @RestController annotation marks the class as a controller where every method returns a domain object instead of a view.
			--> @RestControllerAdvice is a convenience annotation which combines @ControllerAdvice and @ResponseBody. This annotation is used along with the @ExceptionHandler
			
			
			--> @Bean(name="beanB2" , scope=DefaultScopes.PROTOTYPE)
			--> @Qualifier("beanB2")
			--> @CrossOrigin(maxAge = 3600 ,origins = "http://example.com")
			--> @EnableCaching - to enable caching behaviour . mentioned at springboot started class.
			--> @Cacheable - way of enabling the cache behaviour for a method.
			
			--> @Test -  Junit test method.
			--> @MockInject - Inject the object as a mock implimentation.
			--> @Mock - Declare the mock object for test data.
			

			--> @EnableEurekaServer - Netflix’s Eureka is an implementation of a discovery server.(@SpringBootApplication of discovery Server)
			--> @EnableEurekaClient - Netflix’s Eureka is an implementation of a discovery client.(@SpringBootApplication of micro services)
			--> @EnableDiscoveryClient  - annotation to the application/microservice entry point.(@RestController of micro services)
			
				Create BaseController and add  @ModelAttributes for common logics.
			--> @ModelAttribute("sessiontime")  executes at start of for each of the request .(POST ,GET)
			--> if you use PRG ,then one time when the GET is called and one time when redirecting to GET



2) CouchBase/JDBC session:

	COUCHBASE:
			--> Add in application.properties :
						spring.couchbase.bootstrap-hosts=127.0.0.1
						spring.couchbase.bucket.name=SPRING
						spring.couchbase.bucket.password=SPRING
						spring.data.couchbase.auto-index=true
						#define session time out in minutes
						session-couchbase.timeout=11m
						server.servlet.session.cookie.max-age=11m
			
			--> Add in pom.xml :
					<!-- DEPENDENCY TO USE COUCHBASE AS HTTP SESSION  -->
						<dependency>
						   <groupId>com.github.mkopylec</groupId>
						   <artifactId>session-couchbase-spring-boot-starter</artifactId>
						   <version>3.1.1</version>
						</dependency> 
						<dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-data-couchbase</artifactId>
						</dependency>
					
			--> In html ThymeLeaf :
					<span  th:text="${session.loginUserName}" id="loginUserName"></span>
					
	JDBC:
			--> Add in application.properties :
						#Springs session with JDBC com.mysql.jdbc.Driver 
						spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
						spring.datasource.url=jdbc:mysql://127.0.0.1:3306/session
						spring.datasource.jdbc-url=jdbc:mysql://127.0.0.1:3306/session
						spring.datasource.username=root
						spring.datasource.password=Nagu@9046N
						spring.datasource.pool-name=pool-session
						spring.session.store-type=jdbc
						spring.session.jdbc.initialize-schema=always
						spring.session.timeout.seconds=900
			
			--> spring.session.jdbc.initialize-schema=always
						This will create the schema tables to store session data automatically.
						In production we need to execute the scripts manually from 
						"spring-session-jdbc-2.2.0.RELEASE-sources.jar-->org.springframework.session.jdbc-->schema-mysql.sql"
						Refere "schema-hsqldb.sql"
				
			--> Add in pom.xml :
					<!-- DEPENDENCY TO USE MYSQL AS HTTP SESSION  -->
						<dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-jdbc</artifactId>
						</dependency>
						<dependency>
						<groupId>org.springframework.session</groupId>
						<artifactId>spring-session-jdbc</artifactId>
						</dependency>
				        <dependency>
				        	<groupId>mysql</groupId>
				        	<artifactId>mysql-connector-java</artifactId>
				        	<scope>runtime</scope>
				        </dependency>
				        
			--> // Code to establish HikariDataSource for jdbc session from properties in application.properties
					@Bean
				    @Primary
				    @ConfigurationProperties(prefix = "spring.datasource")
				    public HikariConfig hikariConfigmysql_session() {
				        return new HikariConfig();
				    }
				
				    @Bean(name = "mysqlDataSource_session")
				    @Primary
				    public HikariDataSource dataSource_session() {
				        return new HikariDataSource(hikariConfigmysql_session());
				    }
					
			--> In html ThymeLeaf :
					<span  th:text="${session.loginUserName}" id="loginUserName"></span>
			
			
3) No need for server restart on UI changes , and rebuild on java changes:
			--> Add in application.properties :
						spring.devtools.restart.enabled:  false
				
			--> Add in pom.xml :
					<!-- RESTART OF SERVER NOT REQUIRED ON UI CHANGES -->
					  	<dependency>
					        <groupId>org.springframework.boot</groupId>
					        <artifactId>spring-boot-devtools</artifactId>
					        <optional>true</optional>
				    	</dependency> 
    
    
    
4) Server port setup :
			--> Add in application.properties :
						server.port=8080
						server.servlet.context-path=/
				

5) ThymeLeaf UI configuration :
			--> Add in application.properties :
						spring.thymeleaf.cache= false
						spring.thymeleaf.check-template= true
						spring.thymeleaf.check-template-location= true
						spring.thymeleaf.servlet.content-type= text/html
						spring.thymeleaf.enabled= true
						spring.thymeleaf.encoding= UTF-8
						spring.thymeleaf.mode= HTML
						spring.thymeleaf.prefix= classpath:/templates/
						spring.thymeleaf.suffix= .html
				
			--> Add in pom.xml :
					<!-- thymeleaf -->
						<dependency>
				            <groupId>org.springframework.boot</groupId>
				            <artifactId>spring-boot-starter-thymeleaf</artifactId>
				        </dependency>
				        <!-- thymeleaf  LayoutFragment -->
				        <dependency>
				            <groupId>nz.net.ultraq.thymeleaf</groupId>
				            <artifactId>thymeleaf-layout-dialect</artifactId>
				        </dependency>
			        
			--> Add in layout.html :
						<html xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
	      				  xmlns:th="http://www.thymeleaf.org">
	      				  
	      				  <body>
	      				  <th:block th:replace="fragments/header :: header"/>
						    <div class="container">
						        <th:block layout:fragment="content"/>
						    </div>
						    <th:block th:replace="fragments/footer :: footer"/>
				
			--> Add in header.html :
						<body>
						<th:block th:fragment="header">
						
			--> Add in login.html :
						<html xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      						xmlns:th="http://www.thymeleaf.org"
      						layout:decorate="~{fragments/layout}">
      						
  						<body>
						<div layout:fragment="content" th:remove="tag">
				
6) Compile JSP:
			--> Add in pom.xml :
						<dependency>
						    <groupId>org.apache.tomcat</groupId>
						    <artifactId>tomcat-jasper</artifactId>
						    <version>9.0.29</version>
						</dependency>
				
				
7) Jquery and CSS :

			--> Add in pom.xml :
				  	<!-- bootstrap and jquery -->
				        <dependency>
				            <groupId>org.webjars</groupId>
				            <artifactId>bootstrap</artifactId>
				            <version>3.3.7</version>
				        </dependency>
				        <dependency>
				            <groupId>org.webjars</groupId>
				            <artifactId>jquery</artifactId>
				            <version>3.2.1</version>
				        </dependency>
		  
		  	--> Add in layout.html :
		  
					  	<script type="text/javascript" th:src="@{/webjars/jquery/3.2.1/jquery.min.js/}"></script>
						<script type="text/javascript" th:src="@{/webjars/bootstrap/3.3.7/js/bootstrap.min.js}"></script>
					    <link rel="stylesheet" type="text/css" th:href="@{/webjars/bootstrap/3.3.7/css/bootstrap.min.css}"/>
					    <link rel="stylesheet" type="text/css" th:href="@{/css/main.css}"/>
		   
		        
8) To redirect from one controller to another :
						return "redirect:/loadStudentList";
			
			
			
9) To navigate to html :
						return "login";
			
			
10) To pass data and navigate :
						ModelAndView modelAndView = new ModelAndView();
						modelAndView.setViewName("login");
						modelAndView.addObject("login", loginDoc);
						return modelAndView;
			
			
11) To perform form validations :

			--> In model object :
						@NotEmpty(message = "{userName.required}") // @Size(min=2, max=30)
						private String userName="";
			
			--> In controller class :
						public ModelAndView LoginCheck(@Valid Login login, BindingResult bindingResult, HttpSession session) {
				


12) Divide code based on the MVC layers:

					-> Html only for view .
					-> Controller only to accept request and deliver Response .
					-> Service to manipulate the data (before sending to UI ,DB)
					-> Dao , only to retrieve ,insert ,delete to DB.
					-> Model ,  only to hold data from UI and DB .
			
			
13) PRG : Post Redirect Get :

			-->(refer PRG_FAIL.png)
						When we have a POST request (Examle insert form in DB) , 
						then after the request if user refreshes the page (F5),
						The logic for insert form in DB will be duplicated.(refer PRG_FAIL.png)
						
			-->(refer PRG_SUCCESS.png)
						To prevent this , we will redirect from a postMapping request to a GetMapping request of the controller.
						We will execute the insertion in postMapping request , after that we will redirect to a GetMapping request of the controller.
						So when user refresh ,then the GET request is fired and the DB insertion will not be duplicated.
						
						@PostMapping(value = "/saveStudentDetails")
						public ModelAndView saveStudentDetails(@Valid Student student, BindingResult bindingResult, HttpSession session) {
						
						modelAndView.setViewName("redirect:/loadStudentList"); //in "/loadStudentList" controller we will navigate to actual html.
					
					
					
14) Pass form data from Jquery to controller :
				
				
			--> In controller use @RequestBody :
						public ModelAndView updateStudentDetails(@Valid @RequestBody Student student, BindingResult bindingResult,HttpSession session) {
				
			--> In jquery use :
						var form = $("#form").serialize();
						var jsonForm = getJsonForm(form);
						$.ajax({
						data : JSON.stringify(jsonForm),
					
					
					
15)  @Autowired :
 						This we get the required object of the @Component
 						Include the common @Autowired in BaseController ,so that the well be inherited in all subClasses
 
 
 
16 ) Deploy on External Tomcat :

			--> Prepare a war file Pom.xml:
						<!-- packaging to WAR -->
 						<packaging>war</packaging> 
 						
 						<!-- to export as WAR and inform spring boot not to use inbuilt tomcat-->
						<dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-tomcat</artifactId>
							<scope>provided</scope>
						</dependency>
						
						<build>
							<plugins>
								<plugin>
									<groupId>org.springframework.boot</groupId>
									<artifactId>spring-boot-maven-plugin</artifactId>
								</plugin>
							</plugins>
						</build>
						
						
			--> 
						@SpringBootApplication
						public class StudentCbApplication extends SpringBootServletInitializer {//to enable the war file generation , to deploy in external tomcat
						
			-->	Right click -> mavan build -> selct goal as "package"  and select offline , skip Tests.
			--> Select offline will not execute DB or any other server dependencies while the war is generated.
			
			
			
17) Read from message_en.properties :
			--> 
						@SpringBootApplication
						public class StudentCbApplication extends SpringBootServletInitializer {//to enable the war file generation , to deploy in external tomcat
			
				 		@Bean
					    public MessageSource messageSource() {
					        ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();
					        messageSource.setBasename("classpath:message");
					        messageSource.setDefaultEncoding("UTF-8");
					        System.out.println("---messageSourcemessageSource--------------"+messageSource.getMessage("login.fail",null,Locale.ENGLISH));
					        return messageSource;
					    }
				
					    @Bean
					    public LocalValidatorFactoryBean validator() {
					        LocalValidatorFactoryBean bean = new LocalValidatorFactoryBean();
					        bean.setValidationMessageSource(messageSource());
					        return bean;
					    }
					    }
					    
			--> or use the "com.student.app.MessagesConfigurationBean" class.
					    
					    
18) SingelTon :
			--> By default the scope of the @Component is singleton
			--> singleton - Return a single bean instance per Spring IoC container.
			--> prototype – Return a new bean instance each time when requested.(for every @autowired)
			--> request – Return a single bean instance per HTTP request. *
			--> session – Return a single bean instance per HTTP session. ...
			--> globalSession – Return a single bean instance per global HTTP session.
			
			
			
19) XSS :

			--> This will prevent the script injections.
			
			
			
20) unescape :

			--> When using ajax/jquery and calling the controller use unescape() to avoid special char.
					var form = ($("#form").serialize());//works for thymeleaf
					form = unescape(form);
			
			
			
21) SSL : This will make the application run on https

				--> -genkey generates a Secret Key whereas the -genkeypair generates a key pair (a public key and a private key).

				-->	#SSL CONFIGURATION WITH PKCS12
					keytool -genkeypair -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048  -keystore D:\JOB_2020\LOCAL\tomcat_ssl_key/keystore_pkcs12.p12 -validity 3650

						C:\Program Files\Java\jdk1.8.0_191\bin>keytool -genkeypair -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048  -keystore D:\JOB_2020\LOCAL\tomcat_ssl_key/keystore_pkcs12.p12 -validity 3650
								Enter keystore password:martham
								Re-enter new password:martham
								What is your first and last name?
								  [Unknown]:  girish babu martham
								What is the name of your organizational unit?
								  [Unknown]:  self
								What is the name of your organization?
								  [Unknown]:  self
								What is the name of your City or Locality?
								  [Unknown]:  mtm
								What is the name of your State or Province?
								  [Unknown]:  ap
								What is the two-letter country code for this unit?
								  [Unknown]:  in
								Is CN=girish babu martham, OU=self, O=self, L=mtm, ST=ap, C=in correct?
								  [no]:  yes
								  
								  
				 --> Add the following in application.properties :
						
								#SSL CONFIGURATION WITH PKCS12 
								server.port=8443
								server.ssl.key-alias=tomcat
								server.ssl.key-password=martham
								server.ssl.key-store-password=martham
								server.ssl.key-store=D:/JOB_2020/LOCAL/tomcat_ssl_key/keystore_pkcs12.p12
								server.ssl.key-store-provider=SUN
								server.ssl.key-store-type=JKS
				
				--> Generate the keystore without PKCS12 :
					keytool -genkey -alias tomcat -keyalg RSA -keystore D:\JOB_2020\LOCAL\tomcat_ssl_key/keystore.jks
			
						C:\Program Files\Java\jdk1.8.0_191\bin>keytool -genkey -alias tomcat -keyalg RSA -keystore D:\JOB_2020\LOCAL\tomcat_ssl_key/keystore.jks
								Enter keystore password:martham
								Re-enter new password:martham
								What is your first and last name?
								  [Unknown]:  girish babu martham
								What is the name of your organizational unit?
								  [Unknown]:  self
								What is the name of your organization?
								  [Unknown]:  self
								What is the name of your City or Locality?
								  [Unknown]:  mtm
								What is the name of your State or Province?
								  [Unknown]:  ap
								What is the two-letter country code for this unit?
								  [Unknown]:  in
								Is CN=girish babu martham, OU=self, O=self, L=mtm, ST=ap, C=in correct?
								  [no]:  yes
								
								Enter key password for <tomcat>
								        (RETURN if same as keystore password):
								Re-enter new password:
						
						Warning:
						The JKS keystore uses a proprietary format. It is recommended to migrate to PKCS
						12 which is an industry standard format using "keytool -importkeystore -srckeyst
						ore D:\JOB_2020\LOCAL\tomcat_ssl_key/keystore.jks -destkeystore D:\JOB_2020\LOCA
						L\tomcat_ssl_key/keystore.jks -deststoretype pkcs12".
			
			
			--> Add the following in application.properties :
			
								#SSL CONFIGURATION WITH OUT PKCS12 
								server.port=8443
								server.ssl.enabled=true
								server.ssl.key-alias =tomcat
								server.ssl.key-password =martham
								server.ssl.key-store =D:/JOB_2020/LOCAL/tomcat_ssl_key/keystore.jks
								server.ssl.key-store-provider=SUN
								server.ssl.key-store-type = JKS
								  
								  
			--> Check the properties of ketstore :
					keytool -list -keystore D:\JOB_2020\LOCAL\tomcat_ssl_key/keystore.jks
					
						C:\Program Files\Java\jdk1.8.0_191\bin>keytool -list -keystore D:\JOB_2020\LOCAL\tomcat_ssl_key/keystore.jks
								Enter keystore password:
								Keystore type: jks
								Keystore provider: SUN
								
								Your keystore contains 1 entry
								
								tomcat, Jan 27, 2020, PrivateKeyEntry,
								Certificate fingerprint (SHA1): 2B:81:CB:01:B1:BD:7D:F4:28:DD:E9:4A:0D:0F:98:79:
								E4:0E:1E:61
			
					Warning:
					The JKS keystore uses a proprietary format. It is recommended to migrate to PKCS
					12 which is an industry standard format using "keytool -importkeystore -srckeyst
					ore D:\JOB_2020\LOCAL\tomcat_ssl_key/keystore.jks -destkeystore D:\JOB_2020\LOCA
					L\tomcat_ssl_key/keystore.jks -deststoretype pkcs12".
			
			
			--> Finally check the proxy settings to enable HTTS 8443 port (check the anti virus) . 
			
			
22) https and http :

			--> Make application work on both http and https .
			
			--> Add in application properties :
						#additional HTTP port (will open it in HttpServer class)
						server.http.port=8080
						
			--> Use the "com.student.app.BothHttpHttpsConfiguration" class to open http 8080 port
			
			--> Both http://localhost:8080 , https://localhost:8443  will work .
			
			
23) Only htts :

			--> Make application work only on https .
			
			--> Add in application properties :
						#additional HTTPs port (server.port Spring will open it automatically)
						server.port=8443
						
			--> Use the "com.student.app.OnlyHttpsConfiguration" to redirect all http requests to https.
			
			--> http://localhost:8080  will be redirected to https://localhost:8443 
			
			
24) To use default port 80 :

			--> Add in application properties :
					server.http.port=80
					
			--> http://localhost:80 and http://localhost  will be redirected to https://localhost:8443  (23 Only htts)
			
			
			--> http://localhost:80  will be redirected to http://localhost  (22 https and http)
			


25) For SSL production setup :

			--> Generate the ssl keystore as mentioned above.

			--> Add the following in server.xml:
					  	<Connector port="80" protocol="HTTP/1.1"
		               		connectionTimeout="20000"
		               		redirectPort="8443" />
					   
						<Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
		              		 maxThreads="150" scheme="https" secure="true"
			       			keystoreFile="D:/JOB_2020/LOCAL/tomcat_ssl_key/keystore_pkcs12.p12" keystorePass="martham"
		               		clientAuth="false" sslProtocol="TLSv1.2" />


			--> Add the following in web.xml :
						<security-constraint>
							<web-resource-collection>
								<web-resource-name>HTTPSOnly</web-resource-name>
								<url-pattern>/*</url-pattern>
							</web-resource-collection>
							<user-data-constraint>
								<transport-guarantee>CONFIDENTIAL</transport-guarantee>
							</user-data-constraint>	              
					    </security-constraint> 





26) Add Glassfish to STS :
			--> Sapphire update site, http://download.eclipse.org/sapphire/9.1.1/repository , to your list of Available Software Sites so that it can be found.
			--> Add the latest http://download.eclipse.org/glassfish-tools/1.0.0/repository 
			--> Download glassfish5 and unzip to local directory.
			--> Now in STS add the new server and point to the domain2.
			--> Open project properties and assign glassfish server.
			--> Now right click and run on server.
			--> If required you can set the context path,connection pool from glassfish admin console.
		
		
		
27) Deploy in External Glassfish:

			--> D:\JOB_2020\LOCAL\glassfish5.0.1\bin>asadmin

			--> Create new domain:
					asadmin> create-domain --adminport 5000 --profile developer --user admin domain2
 
			--> Start domain :
					asadmin> start-domain domain2
 
			--> Deploy war file :
					asadmin> deploy --port 5000 --host localhost D:/JOB_2020/LOCAL/STS_WORKSPACE/StudentCBThymeLeaf_GF/target/ROOT.war

			--> UnDeploy war file :
					undeploy --port 5000 --host localhost ROOT
 
			--> Stop domain :
					stop-domain domain2  
			 
			--> check the list of domains running :
				 	asadmin> list-domains
					domain1 running
					domain2 not running

			--> open admin console :
					http://localhost:5000
			
			--> open application : 
					http://namratha-vaio:49562/

			--> To auto deploy :
					copy the latest war to "D:\JOB_2020\LOCAL\glassfish5.0.1\glassfish\domains\domain2\autodeploy"
					
			--> Change server ports :
					If you want to change ports check : domain.xml (<network-listener )




28) caching :

			--> Add @EnableCaching in the public class StudentCbApplication extends SpringBootServletInitializer {
			--> Add the following to the service method 
					@Cacheable("standardList")
		   			public List<String> getStandardList() {
			--> The cacheable method will only execute for the first time and there on will return the results from the cache.
			
			
			
29) Rest API (refer RestStudentController.java) :

			--> This is the Restful webservice provided by springs
			--> Define a controller as RestController
					@RestController
					@RequestMapping("/api/student")
			--> Exmaple method :		
					@RequestMapping(value = "/allstudents", produces = MediaType.APPLICATION_JSON_VALUE,  method = RequestMethod.GET)
					public ResponseEntity<ArrayList<Student>> getAllEmployeesJSON(Model model) 
					{
							ArrayList<Student> studentslist = null;
						try {
								studentslist = studentService.getAllStudents();
						
						}catch (Exception e) {
							appLogger.appErrorLog("Exception : ", e);
						}
						return new ResponseEntity<ArrayList<Student>>(studentslist, HttpStatus.OK);
					}




30) Rest Template (refer RestTemplateStudent.java):

			--> This the client to access the Rest API .
						public static void getEmployees()
							{
								try {
								ArrayList<Student> studentslist = null;
							    final String uri = "http://127.0.0.1/api/student/allstudents";
							    //final String uri = "http://127.0.0.1/api/student/allstudents2";//both url will work
							    RestTemplate restTemplate = new RestTemplate();
							   
							    
							    //to get the response as a Arraylist of Objects
							   ResponseEntity<ArrayList<Student>> claimResponse = restTemplate.exchange(
										uri, 
										HttpMethod.GET,
										null,
										new ParameterizedTypeReference<ArrayList<Student>>() {});
								if(claimResponse != null && claimResponse.hasBody()){
									studentslist = claimResponse.getBody();
								}
								
								//to get response as a json string
								//studentslist  = restTemplate.getForObject(uri, ArrayList.class);
								
							   System.err.println("studentsliststudentslist ----------"+studentslist);
							   for(Student student:studentslist) {
								   System.err.println("studentsliststudentslist ----------"+student.getName());
								   
							   }
							   
								}
								catch(Exception e) {
									e.printStackTrace();
								}
							}



31) Basic Authentication :

		Rest API side (webservice, webApplication) :
			
				--> Add in pom.xml 
						<!-- Springs security for basic auth especially for restful webservices  -->
					 	<dependency>
			       		 <groupId>org.springframework.boot</groupId>
			        		<artifactId>spring-boot-starter-security</artifactId>
			    		</dependency>
			    		
				--> Create SpringSecurityConfig.java for basic authentication at the web service side.
			
				--> Define credentails in the application.properties :
						spring.security.user.name=admin
						spring.security.user.password=password2
						spring.security.user.roles=USER
						
				--> Refer RestStudentController.java for the webservice code.
						
			
						
		Rest Template side (Client):
			
			
				--> Add in pom.xml 
					<!-- Basic Auth for the restctemplate client for restful webservice-->
					    <dependency>
					        <groupId>org.apache.httpcomponents</groupId>
					        <artifactId>httpclient</artifactId>
					    </dependency>
					    
				-->	Create RestTemplateStudent.java as client and basic authentication
						 RestTemplate restTemplate = new RestTemplate(getClientHttpRequestFactory());
						 	CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
 							credentialsProvider.setCredentials(AuthScope.ANY, 
                        	new UsernamePasswordCredentials("admin", "password2"));
                        	
                --> For RetsTemplate woth SSL :
                			Refer getSSLRestTemplate() in the RestTemplateStudent.java
						
						
	
	
32 ) Encryption :

			--> you can use the AES	crypto encryption for Rest Api output		.
						encString = aESEncDec.encrypt(gson.toJson(student));
						return new ResponseEntity<String>(encString, HttpStatus.OK);
						
			--> Use AES	crypto decryption for Rest Template 
						Object claimResponse = restTemplate.getForObject(uri,Object.class, params);
						String decString=aESEncDec.decrypt(claimResponse.toString());
					 	student = new Gson().fromJson(decString, Student.class);
					 	
			--> Refer AESEncDec.java
				
				
				

						


33) AOP :
		
			--> This is used to log time taken by each method in a process .
			
			--> add in pom.xml:
					<dependency>
					    <groupId>org.springframework.boot</groupId>
					    <artifactId>spring-boot-starter-aop</artifactId>
					</dependency>

			--> if you want to disable in future add in application.properties:
					#spring.aop.auto = false 

			--> Refer LoggingAspect.java for the implimentation.
			
			--> log file results :
					INFO - RequestedResource="/LoginCheck" SessionId="c044beea-ce51-44fa-9985-370240aeafaa" , Execution time of LoginController.LoginCheck :: 521 ms




34) Email :

			-->Add in pom.xml :
					<dependency>
				        <groupId>org.springframework.boot</groupId>
				        <artifactId>spring-boot-starter-mail</artifactId>
				    </dependency>
		    
		    --> Refer EmailController.java
		    
		    --> Get the mailBody from the emailTemplate ,Refer EmailService.java
		    
		    --> You can use HttpURLConnection or HttpsURLConnection
		    
		    --> For security and Basic authentication :
			    		String basicAuth = "Basic " + new String("YWRtaW46cGFzc3dvcmQy");
						urlConn.setRequestProperty ("Authorization", basicAuth);
						urlConn.setRequestProperty("login", gson.toJson(login));
		
				--> If you use HttpsURLConnection if your website is SSL certified :
						SSLContext ,TrustManager, HostnameVerifier to skip the SSL





35) DataSource :

		we can set up data source in three ways :
		
			--> HikariDataSource :
			
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-jdbc</artifactId>
					</dependency>
					
					or
					
					<dependency>
					    <groupId>com.zaxxer</groupId>
					    <artifactId>HikariCP</artifactId>
					    <version>2.6.1</version>
					</dependency>
					
					-> Create HikariDataSource @Bean and corresponding NamedParameterJdbcTemplate in the @Configuration file.
						Refer DataSourceManager.java
					
					-> In the DAO class use the jdbcTemplate to perform the CRUD operations ,refer StudentmysqlDAO.java :
					 		@Autowired
					 	 	@Qualifier("mysqlTemplate2")
					  		private NamedParameterJdbcTemplate jdbcTemplate;
					-> To check the open connections in the pool run the following command :
							show status like 'Conn%';
		
			--> DBCP2 
					<dependency>
			            <groupId>org.apache.commons</groupId>
			            <artifactId>commons-dbcp2</artifactId>
			            <version>2.1</version>
			        </dependency>
		
			--> Tomcat connection pooling:
					Add the pooling tags in the server.xml,context.xml(tomcat) , domain.xml(glassfish) ,standalone.xml(wildfly)
					Or setup connection pooling from the admin console of application server.
						
						-> dao.java:
					 		@Autowired
						  	@Qualifier("mysqlDataSource3")
						  	private DataSource dataSource;
						
						-> context.xml:
							 <Resource
						    	 name="jdbc/pcmDB"
						    	 auth="Container"
						    	 type="javax.sql.DataSource"
						    	 factory="org.apache.tomcat.jdbc.pool.DataSourceFactory"
						    	 initialSize="5"
						    	 maxActive="5"
						    	 maxIdle="5"
						    	 minIdle="5"
						    	 timeBetweenEvictionRunsMillis="34000"
						    	 minEvictableIdleTimeMillis="55000"
						    	 validationQuery="SELECT 1"
						    	 validationInterval="34"
						    	 testOnBorrow="true"
						    	 removeAbandoned="true"
						    	 removeAbandonedTimeout="233"
						    	 username="root"
						    	 password="Nagu@9046N"
						    	 driverClassName="com.mysql.cj.jdbc.Driver"
						    	 url="jdbc:mysql://127.0.0.1:3306/student"
		   						 />
					
							-> web.xml:
								<resource-ref>
								    <description>DB Connection</description>
								    <res-ref-name>jdbc/student</res-ref-name>
								    <res-type>javax.sql.DataSource</res-type>
								    <res-auth>Container</res-auth>
								</resource-ref>
		
		 					-> wildfly : standalone-full.xml
		 					<datasource jta="false" jndi-name="java:jboss/datasources/OEEWebGold" pool-name="OEEWebGold" enabled="true" use-ccm="false">
			                    <connection-url>jdbc:oracle:thin:@172.16.17.102:1521:stgweb1</connection-url>
			                    <driver-class>oracle.jdbc.OracleDriver</driver-class>
			                    <driver>ojdbc7.jar</driver>
			                    <security>
			                        <user-name>EVENT_SCHEDULER</user-name>
			                        <password>p4tty$h0p101</password>
			                    </security>
			                    <validation>
			                        <validate-on-match>false</validate-on-match>
			                        <background-validation>false</background-validation>
			                    </validation>
			                    <statement>
			                        <share-prepared-statements>false</share-prepared-statements>
			                    </statement>
			                </datasource>
		
    


36) StoredProcedures:
			--> use NamedJdbcTemplate for update operations and list for resultset operations.
			--> Use SimpleJdbctemplate for proedure calls with out param (resultser ,varchar....)s
			--> Refer StudentmysqlProcedureDAO.java
			--> For mysql setup refer resources/documents/mysql/student.sql
			


37) MicroServices :https://www.youtube.com/watch?v=jhvJg4tDrpw


			--> @EnableEurekaServer - Netflix’s Eureka is an implementation of a discovery server.(@SpringBootApplication of discovery Server)
			--> @EnableEurekaClient - Netflix’s Eureka is an implementation of a discovery client.(@SpringBootApplication of micro services)
			--> @EnableDiscoveryClient  - annotation to the application/microservice entry point.(@RestController of micro services)
			--> Create and publish micro services on 2 instances of tomcat server
					We have two instances of Micro service one published with name client1.
					We have two instances of Micro service two published with name client2. 
				    Then we publish Discovery server and we can see the list of micro services active.
				    In code we call micro servive 2 (client2) form micro service 1.
				    
			--> Design pattrens followed :
					API Gate way : All requests will be handled by one Api ,this will intern call the micro services.
					Proxy Pattern : we will have multiple APi gateways to handle mobile, web,and third party 
					Circuit Breaker pattern : If any of the server is down or did not provide  response on time the the circuit is broken.
											  Then  the @HystrixCommand fallbackMethod is executed. Refer Add.java in MicroService1.
											  You should also Enable : @EnableHystrixDashboard , @EnableCircuitBreaker
			--> For Architecture refer documents/microservices/micro_architecture.png  
											
											  
										
			
			
			Here we will have multiple Rest Api servers.
			We will have one main service to call other micro services as mentioned in step1, we use the RestTemplate or the MicroClient.build.
			
			Eureka service:
			To identify the available micro services (clients) we use the Eurika service.And this is called as the Discovery Server .
			Get the dependency Eurika service and jsxb for java10 and above.
			Default port of EurekaServer is 8761.
			Add the properties in Eureka Server ,since we have only onle eureka server-->
					eureka.client.register-with-eurika=false
					eureka.client.fetch-registry=false
			Add @EnableEurikServer for springbootstarted class
				
				
					
			Eureka client:
			Now the micro services need Eurika client to inform the Eureka server that they are present and register in the Eureka Server.
			Only then we can have the miro services will be present in the list i=of instances registered at :http://localhost:8761
			Add the following dependency spring cloud eurika client in the micro services:
							<dependency>
				        	<groupId>org.springframework.cloud</groupId>
				        	<artifactId>
				        		spring-cloud-starter-netflix-eureka-client
				        	</artifactId>
				        </dependency>
				        
			Add server.port=8081
				spring.application.name=client1
			Add @EnableEurikClient for springbootstarted class
			

			
			Each spring rest micro server is a Eureka client
			we will have a descovery server , which is the Eureka server.
			Since we are calling rest service for another rest service using resrtemplate with hardcoded url (http://localhost:8080/service1/id)
			we need to remove this hardcoded urls form the restTemplate.
			The resttemplte should be defines as @Bean and use @LoadBalanced, now chnage the url to http://{springs.application.name}/service1/id
			
			Always start the client micro services in the order of the dependency, if client 1 calls client2 - start client2 first and get it ready
			
			Run each of the micro service clients on different ports at local env. micro service clients:8081 ,micro service clients2:8082 ,micro service clients3:8083
			If you want to have multiple instances for each of the micro service clients ,micro service clients:8091 ,micro service clients:8092 ,micro service clients:8093 then :
			java -Dserver.port=8087 -jar F:\CLIEN1.jar com.example.demo.DemoApplication
			This is when the @LoadBalanced to get RestTemplate chooses between the different instances of same micro service client - refer resources/documents/microservices/microservices.png
			
			
			when the eureka client or the micros service is down , this will be identified by the discovery server implicetly by heartbeats (some thing like the keepalive check at frequent intervals)
			When the discovery server goes down , this will again be handles by the cache to have a fail over message.




38) Exceptional Handling :
				--> we just need to use the @ControllerAdvice .
				--> This will configure the Exception for all the controllers
				--> If there is any issue with  @ControllerAdvice  ,just try to rename the controller package.
				--> Refer the HandleError.java



39) Junit and Mokito : Refer the test package



40 ) Design Patterns :


37) Hibernate :

https://howtodoinjava.com/spring-boot2/crud-application-thymeleaf/



38) External application.properties :
https://youtu.be/Sw-PyulH1Jg




29)
check the SSL setup for glassfish

D:/JOB_2020/LOCAL/tomcat_ssl_key/keystore_pkcs12.p12

Here’s the command to import your keystore into the GlassFish one:
keytool -importkeystore -srckeystore D:/JOB_2020/LOCAL/tomcat_ssl_key/keystore_pkcs12.p12 -destkeystore keystore.jks





29) @SpringBootApplication is executed first
	@Configuration files will be executed first on server startup .
    Then singleTon @components will be executed
    Then constructor of normal @Components
    @SpringBootApplication will auto configure all the beans in the application.
    @SpringBootApplication is a single annotation which is combination of  :@Configuration ,@EnableAutoConfiguration ,@ComponentScan
    use @EnableAutoConfiguration(excludeName = {"multipartResolver","mbeanServer"}) to exclude any beans not to be configured/scanned.
    
    
30) AOP :


https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html

For example, DispatcherServlet will look for @RequestMapping on classes which are annotated using @Controller but not with @Component.
Read more: https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html#ixzz6CJj25xhP
